<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <title>Mapa Interactivo con GeoJSON y Firebase Firestore</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="module">
        // Importa las funciones necesarias de los SDKs de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs } from 'https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js';

        // Tu configuración de Firebase (obtenida de la consola de Firebase)
        // NOTA: Para un entorno real, estas claves deben ser manejadas de forma más segura.
        const firebaseConfig = {
            apiKey: "AIzaSyCoxbm_jXwcC3bRHC7uYcqKmKO-BA7zBy0",
            authDomain: "mapasaltaparcelas-dfeb0.firebaseapp.com",
            projectId: "mapasaltaparcelas-dfeb0",
            storageBucket: "mapasaltaparcelas-dfeb0.firebasestorage.app",
            messagingSenderId: "783736714984",
            appId: "1:783736714984:web:5839f8049f515cba3d7b5d"
        };

        // Inicializa Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Hace que las funciones y la instancia de la base de datos estén disponibles globalmente
        // Esto es necesario porque el script principal no es un módulo directamente
        window.db = db;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.collection = collection;
        window.query = query;
        window.where = where;
        window.getDocs = getDocs;
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>

    <style>
        /* Estilos personalizados para elementos de Leaflet y anulaciones de Tailwind */
        html, body, #map {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif; /* Usando Inter para un aspecto moderno */
        }
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 3px 14px rgba(0,0,0,0.3);
        }
        .leaflet-popup-content {
            font-size: 14px;
            line-height: 1.6;
            margin: 15px;
            max-height: 300px; /* Para popups con mucho contenido */
            overflow-y: auto;
        }
        .leaflet-popup-content h4 {
            margin-top: 0;
            margin-bottom: 12px;
            color: #333;
            font-size: 17px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        .leaflet-popup-content strong {
            color: #0056b3;
        }
        .leaflet-popup-content hr {
            margin: 12px 0;
            border: 0;
            border-top: 1px solid #eee;
        }
        .popup-section {
            margin-bottom: 15px;
        }
        .popup-section label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        .popup-section textarea,
        .popup-section input[type="text"],
        .popup-section input[type="number"] {
            width: calc(100% - 16px); /* Ajustar para el padding */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: inherit;
            font-size: 13px;
            margin-bottom: 8px;
            box-sizing: border-box; /* Incluir padding en el ancho */
        }
        .popup-section input[type="color"] {
            width: 50px;
            height: 30px;
            padding: 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            margin-right: 10px;
        }
        .popup-button {
            background-color: #007bff;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
        }
        .popup-button:hover {
            background-color: #0056b3;
        }
        .popup-button.secondary {
            background-color: #6c757d;
        }
        .popup-button.secondary:hover {
            background-color: #545b62;
        }
        .color-picker-container {
            display: flex;
            align-items: center;
        }
        /* Contenedores de mensajes globales */
        #loading-message, #error-message-container, #search-message-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffdddd;
            border: 1px solid #ff0000;
            color: #d8000c;
            padding: 15px;
            border-radius: 5px;
            z-index: 2000; /* Encima del mapa */
            text-align: center;
            display: none; /* Oculto por defecto */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #loading-message {
            background: #e0efff;
            border: 1px solid #007bff;
            color: #0056b3;
        }
        #search-message-container {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        /* Contenedor de la barra de búsqueda */
        #search-bar-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column; /* Apilar la entrada de búsqueda y los resultados verticalmente */
            gap: 8px;
            align-items: flex-start; /* Alinear elementos al inicio */
        }
        #search-bar-container input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            width: 200px; /* Ancho fijo para la entrada */
        }
        #search-bar-container .search-controls {
            display: flex;
            gap: 8px;
            width: 100%;
        }
        #search-bar-container button {
            padding: 8px 12px;
            background-color: #28a745; /* Verde para buscar */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            flex-grow: 1; /* Permitir que el botón crezca */
        }
        #search-bar-container button:hover {
            background-color: #218838;
        }

        /* Estilo de los resultados de búsqueda */
        #search-results-container {
            max-height: 300px; /* Limitar altura para desplazamiento */
            overflow-y: auto;
            width: 100%;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #eee;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            display: none; /* Oculto por defecto */
        }
        .search-result-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: #333;
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item:hover {
            background-color: #e9e9e9;
        }
        .search-result-item strong {
            color: #007bff;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="loading-message">Cargando datos...</div>
    <div id="error-message-container"></div>
    <div id="search-message-container"></div>

    <div id="search-bar-container">
        <div class="search-controls">
            <input type="text" id="searchInput" placeholder="Buscar por N° Catastro..." class="flex-grow" />
            <input type="text" id="searchLocalidadInput" placeholder="Filtrar por Localidad..." class="flex-grow" />
            <button id="searchButton">Buscar</button>
        </div>
        <div id="search-results-container">
        </div>
    </div>

    <script>
        // --- Configuración Global ---
        const GEOJSON_FILE = 'archivo.geojson'; // Asegúrate de que este archivo exista y esté simplificado
        const PARCELAS_COLLECTION = 'parcelas_personalizadas'; // Nombre de tu colección en Firestore
        const DEFAULT_FILL_COLOR = '#3498DB'; // Azul por defecto
        const DEFAULT_BORDER_COLOR = '#2980B9';
        const MIN_ZOOM_LEVEL_FOR_PARCELS = 18; // Nivel de zoom para mostrar parcelas (CAMBIADO A 13 PARA PRUEBAS)

        let map;
        let geojsonLayer;
        let geojsonDataGlobal = null; // Almacenará los datos GeoJSON (features)
        const featureIdToLayerMap = new Map(); // Mapea unique_id de feature a su layer Leaflet

        // --- Inicialización del Mapa ---
        function initMap() {
            // Inicializa el mapa con una vista por defecto, ajustada para Salta, Salta Province, Argentina
            map = L.map('map').setView([-24.782, -65.411], 13); // Centrado alrededor de la ciudad de Salta
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            map.on('zoomend', updateGeoJsonVisibility);
        }

        // --- Carga de Datos (GeoJSON local y Firestore) ---
        async function loadAndProcessGeoJSON() {
            document.getElementById('loading-message').style.display = 'block';
            let features = null;

            try {
                // 1. Cargar el GeoJSON simplificado localmente
                const response = await fetch(GEOJSON_FILE);
                if (!response.ok) {
                    throw new Error(`Error HTTP ${response.status}: ${response.statusText} al cargar ${GEOJSON_FILE}`);
                }
                const rawData = await response.json();
                if (!rawData.features || !Array.isArray(rawData.features)) {
                    throw new Error("El archivo GeoJSON no tiene un formato válido (falta array 'features').");
                }
                features = rawData.features;

                // Asignar/verificar unique_id si no existe
                features.forEach((feature, index) => {
                    if (!feature.properties) feature.properties = {};
                    if (!feature.properties.unique_id) {
                        // Prioriza propiedades comunes de catastro para unique_id
                        const potentialIds = ['CATASTRO', 'N_CATASTRO', 'NUM_CATASTRO', 'CAT_NUM', 'id', 'ID', 'gid', 'objectid', 'ID_PARCELA'];
                        let foundId = null;
                        for (const pid of potentialIds) {
                            if (feature.properties[pid] !== undefined && feature.properties[pid] !== null && String(feature.properties[pid]).trim() !== '') {
                                foundId = String(feature.properties[pid]);
                                break;
                            }
                        }
                        feature.properties.unique_id = foundId || `parcela_generated_${index}`;
                    }
                });

                geojsonDataGlobal = { type: "FeatureCollection", features: features };
                console.log(`Datos GeoJSON cargados desde: ${GEOJSON_FILE}`);

                // 2. Cargar datos personalizados de Firestore y fusionarlos
                await loadCustomParcelDataFromFirestore();

                renderGeoJSONLayer();
                document.getElementById('loading-message').style.display = 'none';
                initializeFuse(); // Inicializar Fuse.js después de cargar y fusionar los datos

            } catch (err) {
                console.error('Error cargando o procesando los datos:', err);
                displayGlobalError(`No se pudieron cargar los datos. Verifique la consola para más detalles. Mensaje: ${err.message}`);
                document.getElementById('loading-message').style.display = 'none';
            }
        }

        /**
         * Carga los datos personalizados de las parcelas desde Firestore y los fusiona
         * con las propiedades de las features GeoJSON existentes en geojsonDataGlobal.
         */
        async function loadCustomParcelDataFromFirestore() {
            // Asegúrate de que Firebase se haya inicializado y 'db' esté disponible
            if (!window.db) {
                console.warn("Firebase no está inicializado. No se cargarán datos personalizados.");
                return;
            }

            try {
                // Obtiene una referencia a la colección de parcelas personalizadas
                const parcelsRef = window.collection(window.db, PARCELAS_COLLECTION);
                // Obtiene todos los documentos de la colección
                const snapshot = await window.getDocs(parcelsRef);

                // Itera sobre cada documento (parcela personalizada)
                snapshot.forEach(doc => {
                    const customData = doc.data(); // Obtiene los datos del documento
                    const uniqueId = doc.id; // El ID del documento es el unique_id de nuestra parcela

                    // Encuentra la feature GeoJSON correspondiente en el array global
                    const feature = geojsonDataGlobal.features.find(f => f.properties.unique_id === uniqueId);
                    if (feature) {
                        // Fusiona las propiedades personalizadas del documento de Firestore.
                        // Object.assign sobrescribe las propiedades si ya existen.
                        Object.assign(feature.properties, customData);
                    }
                });
                console.log("Datos personalizados cargados y fusionados desde Firestore.");
            } catch (error) {
                console.error("Error al cargar datos personalizados de Firestore:", error);
                displayGlobalError("Error al cargar datos personalizados desde la base de datos.");
            }
        }

        /**
         * Guarda una propiedad personalizada de una parcela en Firestore.
         * @param {string} featureId - El unique_id de la parcela.
         * @param {string} propertyName - El nombre de la propiedad a guardar (ej. 'observacion_usuario').
         * @param {*} value - El valor a guardar para la propiedad.
         */
        async function saveCustomPropertyToFirestore(featureId, propertyName, value) {
            // Asegúrate de que Firebase se haya inicializado
            if (!window.db) {
                console.error("Firebase no está inicializado. No se pueden guardar datos.");
                return;
            }

            const feature = geojsonDataGlobal.features.find(f => f.properties.unique_id === featureId);
            if (!feature) {
                console.error(`Característica con ID ${featureId} no encontrada para guardar.`);
                return;
            }

            // NOTA: La actualización local de feature.properties[propertyName] = value;
            // se hace ahora en aplicarColorParcela/resetearColorParcela antes de llamar a esta función.
            // Esto asegura que la propiedad ya esté actualizada cuando getFeatureStyle es llamado.

            // Preparar el objeto de datos que se enviará a Firestore.
            // Solo incluimos las propiedades personalizadas que manejamos.
            const customDataToSave = {
                observacion_usuario: feature.properties.observacion_usuario || null,
                superficie_usuario: (feature.properties.superficie_usuario === undefined || feature.properties.superficie_usuario === '') ? null : parseFloat(feature.properties.superficie_usuario),
                construido_usuario: (feature.properties.construido_usuario === undefined || feature.properties.construido_usuario === '') ? null : parseFloat(feature.properties.construido_usuario),
                valor_usuario: (feature.properties.valor_usuario === undefined || feature.properties.valor_usuario === '') ? null : parseFloat(feature.properties.valor_usuario),
                color_personalizado_relleno: feature.properties.color_personalizado_relleno || null,
                color_personalizado_borde: feature.properties.color_personalizado_borde || null,
            };

            // Eliminar propiedades con valor null/undefined para no guardarlas si no tienen valor
            for (const key in customDataToSave) {
                if (customDataToSave[key] === null || customDataToSave[key] === undefined || customDataToSave[key] === '') {
                    delete customDataToSave[key];
                }
            }
            
            try {
                // Obtiene una referencia al documento específico en la colección
                const docRef = window.doc(window.db, PARCELAS_COLLECTION, featureId);
                // setDoc con { merge: true } fusiona los datos, no sobrescribe el documento completo.
                // Esto es crucial para no eliminar otras propiedades si las hubiera.
                await window.setDoc(docRef, customDataToSave, { merge: true });
                console.log(`Propiedad '${propertyName}' guardada para ${featureId} en Firestore.`);

                // Refrescar el popup si está abierto para mostrar el valor actualizado
                const layer = featureIdToLayerMap.get(featureId);
                if (layer && layer.isPopupOpen()) {
                    layer.setPopupContent(generarContenidoPopup(featureId));
                }
            } catch (error) {
                console.error("Error al guardar en Firestore:", error);
                displayGlobalError(`Error al guardar los cambios para la parcela ${featureId}.`);
            }
        }

        // --- Funciones de Utilidad y UI ---
        function displayGlobalError(message) {
            const errorContainer = document.getElementById('error-message-container');
            errorContainer.textContent = message;
            errorContainer.style.display = 'block';
            setTimeout(() => { errorContainer.style.display = 'none'; }, 10000); // Ocultar después de 10 segundos
        }

        function displaySearchMessage(message, isError = false) {
            const searchMessageContainer = document.getElementById('search-message-container');
            searchMessageContainer.textContent = message;
            searchMessageContainer.style.backgroundColor = isError ? '#ffdddd' : '#fff3cd';
            searchMessageContainer.style.borderColor = isError ? '#ff0000' : '#ffeeba';
            searchMessageContainer.style.color = isError ? '#d8000c' : '#856404';
            searchMessageContainer.style.display = 'block';
            setTimeout(() => { searchMessageContainer.style.display = 'none'; }, 3000); // Ocultar después de 3 segundos
        }

        function getFeatureStyle(feature) {
            const props = feature.properties;
            let fillColor = props.color_personalizado_relleno || DEFAULT_FILL_COLOR;
            let borderColor = props.color_personalizado_borde || DEFAULT_BORDER_COLOR;
            let fillOpacity = 0.5;

            console.log(`[getFeatureStyle] Feature ID: ${props.unique_id}`);
            console.log(`[getFeatureStyle] Initial properties for style calculation:`, props);

            // Lógica de color basada en TIPO_USO solo si no hay un color personalizado
            if (!props.color_personalizado_relleno && props.TIPO_USO) {
                switch (props.TIPO_USO.toLowerCase()) {
                    case 'agricola': case 'agrícola': fillColor = '#2ECC71'; borderColor = chroma(fillColor).darken(0.5).hex(); break;
                    case 'urbano': fillColor = '#E74C3C'; borderColor = chroma(fillColor).darken(0.5).hex(); break;
                    case 'industrial': fillColor = '#F39C12'; borderColor = chroma(fillColor).darken(0.5).hex(); break;
                    case 'protegido': case 'reserva': fillColor = '#1ABC9C'; borderColor = chroma(fillColor).darken(0.5).hex(); fillOpacity = 0.6; break;
                    default: /* no-op */ break; // Mantener el color por defecto si no coincide
                }
                console.log(`[getFeatureStyle] Using TIPO_USO logic. Fill: ${fillColor}, Border: ${borderColor}`);
            } else if (props.color_personalizado_relleno) { // Si hay un color de relleno personalizado, usarlo.
                // Si no hay un color de borde personalizado, derivarlo del de relleno.
                if (!props.color_personalizado_borde) {
                    try {
                        borderColor = chroma(fillColor).darken(1).hex();
                    } catch (e) {
                        borderColor = fillColor; // Fallback si chroma falla
                        console.warn("[getFeatureStyle] Chroma.js no disponible o falló para derivar el borde, usando color de relleno para el borde.");
                    }
                }
                console.log(`[getFeatureStyle] Using custom colors. Fill: ${fillColor}, Border: ${borderColor}`);
            }
            // Si no hay color personalizado ni TIPO_USO, usará DEFAULT_FILL_COLOR y DEFAULT_BORDER_COLOR.
            console.log(`[getFeatureStyle] Final style: { color: ${borderColor}, weight: 2, fillColor: ${fillColor}, fillOpacity: ${fillOpacity} }`);
            return { color: borderColor, weight: 2, fillColor: fillColor, fillOpacity: fillOpacity };
        }

        function generarContenidoPopup(featureId) {
            const feature = geojsonDataGlobal.features.find(f => f.properties.unique_id === featureId);
            if (!feature) return "Error: Parcela no encontrada.";

            const props = feature.properties;
            let content = `<h4>Detalles de la Parcela</h4>`;
            const excludedProperties = [
                'unique_id', 'color_personalizado_relleno', 'color_personalizado_borde',
                'observacion_usuario', 'superficie_usuario', 'construido_usuario', 'valor_usuario',
                'SHAPE_Leng', 'SHAPE_Area', 'VINCULACIO', 'COD_MANZAN'
            ];

            // Mostrar propiedades existentes de la parcela (excluyendo las personalizadas y las técnicas)
            for (const key in props) {
                if (props.hasOwnProperty(key) && !excludedProperties.includes(key) && props[key] !== undefined && props[key] !== null) {
                    let displayKey = key.replace(/_/g, ' ');
                    displayKey = displayKey.charAt(0).toUpperCase() + displayKey.slice(1).toLowerCase();
                    content += `<strong>${displayKey}</strong>: ${props[key]}<br>`;
                }
            }
            content += `<hr>`;

            // Campos editables para propiedades personalizadas del usuario
            content += `<div class="popup-section">
                                <label for="obs-input-${featureId}">Observaciones:</label>
                                <textarea id="obs-input-${featureId}" placeholder="Escriba sus observaciones aquí..." onchange="guardarPropiedad('${featureId}', 'observacion_usuario', this.value)">${props.observacion_usuario || ''}</textarea>
                            </div>`;
            content += `<div class="popup-section">
                                <label for="superficie-input-${featureId}">Superficie ($m^2$):</label>
                                <input type="number" id="superficie-input-${featureId}" placeholder="Ingrese superficie" value="${props.superficie_usuario || ''}" onchange="guardarPropiedad('${featureId}', 'superficie_usuario', this.value)">
                            </div>`;
            content += `<div class="popup-section">
                                <label for="construido-input-${featureId}">Construido ($m^2$):</label>
                                <input type="number" id="construido-input-${featureId}" placeholder="Ingrese superficie construida" value="${props.construido_usuario || ''}" onchange="guardarPropiedad('${featureId}', 'construido_usuario', this.value)">
                            </div>`;
            content += `<div class="popup-section">
                                <label for="valor-input-${featureId}">Valor ($USD$):</label>
                                <input type="number" id="valor-input-${featureId}" placeholder="Ingrese valor" value="${props.valor_usuario || ''}" onchange="guardarPropiedad('${featureId}', 'valor_usuario', this.value)">
                            </div><hr>`;

            // Selector de color
            const currentColor = props.color_personalizado_relleno || DEFAULT_FILL_COLOR;
            content += `<div class="popup-section">
                                <label for="color-picker-${featureId}">Color de Parcela:</label>
                                <div class="color-picker-container">
                                    <input type="color" id="color-picker-${featureId}" value="${currentColor}">
                                    <button class="popup-button" onclick="aplicarColorParcela('${featureId}')">Aplicar Color</button>
                                </div>
                                <button class="popup-button secondary" style="margin-top:5px;" onclick="resetearColorParcela('${featureId}')">Resetear Color</button>
                            </div>`;
            return content;
        }

        function onEachFeature(feature, layer) {
            const featureId = feature.properties.unique_id;
            featureIdToLayerMap.set(featureId, layer);
            layer.bindPopup(() => generarContenidoPopup(featureId), { minWidth: 280, maxWidth: 350 });
        }

        function renderGeoJSONLayer() {
            if (geojsonLayer) {
                map.removeLayer(geojsonLayer);
                featureIdToLayerMap.clear(); // Limpiar el mapa de capas ya que se eliminan las capas
            }
            if (geojsonDataGlobal && geojsonDataGlobal.features && geojsonDataGlobal.features.length > 0) {
                geojsonLayer = L.geoJSON(geojsonDataGlobal, {
                    style: getFeatureStyle,
                    onEachFeature: onEachFeature
                });
                updateGeoJsonVisibility();
                // Ajusta los límites del mapa solo si la capa GeoJSON tiene límites válidos
                try {
                    map.fitBounds(geojsonLayer.getBounds());
                } catch (e) {
                    console.warn("No se pudieron ajustar los límites del mapa. Asegúrate de que el GeoJSON tenga geometrías válidas.", e);
                }
            } else {
                displayGlobalError("No hay datos de parcelas para mostrar. El archivo puede estar vacío o hubo un error al procesarlo.");
            }
        }

        function updateGeoJsonVisibility() {
            if (!map || !geojsonLayer) return;
            const currentZoom = map.getZoom();
            if (currentZoom >= MIN_ZOOM_LEVEL_FOR_PARCELS) {
                if (!map.hasLayer(geojsonLayer)) {
                    map.addLayer(geojsonLayer);
                }
            } else {
                if (map.hasLayer(geojsonLayer)) {
                    map.removeLayer(geojsonLayer);
                }
            }
        }

        /**
         * Función wrapper para guardar una propiedad de la parcela en Firestore.
         * Se llama desde los eventos 'onchange' de los inputs del popup.
         */
        window.guardarPropiedad = function(featureId, propertyName, value) {
            const feature = geojsonDataGlobal.features.find(f => f.properties.unique_id === featureId);
            if (feature) {
                // Parsear a float si es un campo numérico, de lo contrario, mantener el valor
                const finalValue = (propertyName.includes('superficie') || propertyName.includes('construido') || propertyName.includes('valor'))
                                                ? (value === '' ? null : parseFloat(value)) // Guarda null si está vacío
                                                : value;
                // Actualizar la propiedad localmente antes de guardar en Firestore
                feature.properties[propertyName] = finalValue;
                saveCustomPropertyToFirestore(featureId, propertyName, finalValue);
            }
        }

        /**
         * Aplica un color personalizado a una parcela y lo guarda en Firestore.
         */
        window.aplicarColorParcela = async function(featureId) {
            const feature = geojsonDataGlobal.features.find(f => f.properties.unique_id === featureId);
            const colorInput = document.getElementById(`color-picker-${featureId}`);
            if (feature && colorInput) {
                const nuevoColorRelleno = colorInput.value;
                let nuevoColorBorde;
                try {
                    nuevoColorBorde = chroma(nuevoColorRelleno).darken(1).hex();
                } catch (e) {
                    nuevoColorBorde = nuevoColorRelleno; // Fallback
                    console.warn("Chroma.js no disponible o falló para derivar el borde, usando color de relleno para el borde.");
                }

                // --- ACTUALIZACIÓN LOCAL EXPLÍCITA DE LAS PROPIEDADES DE COLOR ---
                feature.properties.color_personalizado_relleno = nuevoColorRelleno;
                feature.properties.color_personalizado_borde = nuevoColorBorde;
                // --- FIN DE LA ACTUALIZACIÓN LOCAL EXPLÍCITA ---

                console.log(`[aplicarColorParcela] Aplicando color para ${featureId}. Relleno: ${nuevoColorRelleno}, Borde: ${nuevoColorBorde}`);
                console.log("[aplicarColorParcela] Propiedades de la feature DESPUÉS de la actualización local y ANTES de Firestore:", feature.properties);


                // Guardar ambos colores en Firestore (ahora saveCustomPropertyToFirestore solo confirmará/persistirá lo que ya está configurado localmente)
                await saveCustomPropertyToFirestore(featureId, 'color_personalizado_relleno', nuevoColorRelleno);
                await saveCustomPropertyToFirestore(featureId, 'color_personalizado_borde', nuevoColorBorde);

                console.log("[aplicarColorParcela] Propiedades de la feature DESPUÉS de guardar en Firestore (localmente actualizadas):", feature.properties);

                const layer = featureIdToLayerMap.get(featureId);
                if (layer) {
                    const newStyle = getFeatureStyle(feature); // Obtener el nuevo estilo basado en las propiedades de la característica actualizadas
                    console.log("[aplicarColorParcela] Nuevo estilo calculado para la capa:", newStyle);
                    layer.setStyle(newStyle); // Aplicar el nuevo estilo directamente a la capa de Leaflet
                    console.log(`[aplicarColorParcela] Color actualizado para la capa ${featureId}.`);
                } else {
                    console.warn(`[aplicarColorParcela] Capa para featureId ${featureId} no encontrada en el mapa.`);
                }

                // Refrescar el popup si está abierto para mostrar el valor actualizado
                if (layer && layer.isPopupOpen()) {
                    layer.setPopupContent(generarContenidoPopup(featureId));
                }
            }
        }

        /**
         * Resetea el color de una parcela a su estilo por defecto y elimina los colores personalizados de Firestore.
         */
        window.resetearColorParcela = async function(featureId) {
            const feature = geojsonDataGlobal.features.find(f => f.properties.unique_id === featureId);
            if (feature) {
                console.log(`[resetearColorParcela] Reseteando color para ${featureId}.`);

                // --- ACTUALIZACIÓN LOCAL EXPLÍCITA PARA ELIMINAR LAS PROPIEDADES DE COLOR ---
                delete feature.properties.color_personalizado_relleno;
                delete feature.properties.color_personalizado_borde;
                // --- FIN DE LA ACTUALIZACIÓN LOCAL EXPLÍCITA ---

                // Guardar null en Firestore para eliminar estas propiedades
                await saveCustomPropertyToFirestore(featureId, 'color_personalizado_relleno', null);
                await saveCustomPropertyToFirestore(featureId, 'color_personalizado_borde', null);

                console.log("[resetearColorParcela] Propiedades de la feature DESPUÉS de resetear en Firestore (localmente actualizadas):", feature.properties);

                const layer = featureIdToLayerMap.get(featureId);
                if (layer) {
                    const newStyle = getFeatureStyle(feature); // Obtener el estilo por defecto de nuevo basado en las propiedades de la característica actualizadas
                    console.log("[resetearColorParcela] Nuevo estilo calculado para la capa:", newStyle);
                    layer.setStyle(newStyle); // Aplicar el nuevo estilo directamente a la capa de Leaflet
                    console.log(`[resetearColorParcela] Color reseteado para la capa ${featureId}.`);
                } else {
                    console.warn(`[resetearColorParcela] Capa para featureId ${featureId} no encontrada en el mapa.`);
                }

                // Refrescar el popup si está abierto para mostrar el valor actualizado
                if (layer && layer.isPopupOpen()) {
                    layer.setPopupContent(generarContenidoPopup(featureId));
                }
            }
        }

        // Inicializar mapa y cargar datos
        initMap();
        // Llamar a loadAndProcessGeoJSON y luego inicializar Fuse.js
        loadAndProcessGeoJSON();

        // --- Funcionalidad de Búsqueda ---
        let fuse; // Almacenará la instancia de Fuse.js

        document.getElementById('searchButton').addEventListener('click', performSearch);
        document.getElementById('searchInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        });
        // Nuevo: Búsqueda al presionar Enter en el input de localidad
        document.getElementById('searchLocalidadInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                performSearch();
            }
        });


        function initializeFuse() {
            if (!geojsonDataGlobal || !geojsonDataGlobal.features) {
                console.warn("No hay datos GeoJSON para inicializar Fuse.js.");
                return;
            }
            const options = {
                keys: [
                    { name: 'properties.CATASTRO', weight: 0.8 }, // Más peso al catastro
                    { name: 'properties.N_CATASTRO', weight: 0.8 }, // Asegurar que N_CATASTRO también se busque
                    { name: 'properties.unique_id', weight: 0.2 }, // ID único como fallback
                    { name: 'properties.LOCALID', weight: 0.5 }, // Añadimos LOCALID con un peso menor
                ],
                threshold: 0.3, // Ajusta la "fuzziness". 0 es exacto, 1 es muy difuso.
                ignoreLocation: true, // Ignorar la ubicación del patrón en la cadena
                distance: 100, // Qué tan lejos puede estar la coincidencia
            };
            fuse = new Fuse(geojsonDataGlobal.features, options);
            console.log("Índice de Fuse.js inicializado para la búsqueda con Catastro y Localidad.");
        }

        async function performSearch() {
            const searchTermCatastro = document.getElementById('searchInput').value.trim();
            const searchTermLocalidad = document.getElementById('searchLocalidadInput').value.trim(); // Nuevo input de localidad

            const searchResultsContainer = document.getElementById('search-results-container');
            searchResultsContainer.innerHTML = ''; // Limpiar resultados anteriores
            searchResultsContainer.style.display = 'none'; // Ocultar resultados por defecto

            if (!searchTermCatastro && !searchTermLocalidad) { // Si ambos están vacíos
                displaySearchMessage("Por favor, ingrese un N° Catastro o Localidad para buscar.");
                return;
            }

            if (!fuse) {
                displaySearchMessage("El índice de búsqueda no está listo. Intente de nuevo en unos segundos.", true);
                return;
            }

            displaySearchMessage("Buscando...");

            let combinedSearchTerm = '';
            if (searchTermCatastro) {
                combinedSearchTerm += searchTermCatastro;
            }
            if (searchTermLocalidad) {
                // Añadir espacio si ya hay un término de catastro para separar
                if (combinedSearchTerm) {
                    combinedSearchTerm += ' ';
                }
                combinedSearchTerm += searchTermLocalidad;
            }
            
            console.log(`[performSearch] Término de búsqueda combinado: "${combinedSearchTerm}"`);
            const results = fuse.search(combinedSearchTerm);

            if (results.length > 0) {
                displaySearchMessage(`Se encontraron ${results.length} resultados.`);
                searchResultsContainer.style.display = 'block';
                results.slice(0, 10).forEach(result => { // Mostrar solo los primeros 10 resultados
                    const feature = result.item;
                    const resultItem = document.createElement('div');
                    resultItem.classList.add('search-result-item');
                    // Mostrar Catastro y Localidad en el resultado
                    resultItem.innerHTML = `<strong>Catastro:</strong> ${feature.properties.CATASTRO || feature.properties.N_CATASTRO || 'N/A'}<br>
                                            <strong>Localidad:</strong> ${feature.properties.LOCALID || 'N/A'}`;
                    resultItem.onclick = () => {
                        const layer = featureIdToLayerMap.get(feature.properties.unique_id);
                        if (layer) {
                            // Ajustar el mapa al centro de la parcela y abrir el popup
                            map.flyTo(layer.getBounds().getCenter(), MIN_ZOOM_LEVEL_FOR_PARCELS + 1); // Zoom un poco más cerca
                            if (layer.getBounds().isValid()) { // Verificar si los límites son válidos antes de intentar ajustar
                                map.fitBounds(layer.getBounds().pad(0.5)); // Ajustar el zoom para que se vea la parcela
                            }
                            layer.openPopup();
                            displaySearchMessage(`Parcela ${feature.properties.unique_id} encontrada.`);
                        } else {
                            displaySearchMessage(`No se encontró la capa para la parcela ${feature.properties.unique_id}.`, true);
                        }
                        searchResultsContainer.style.display = 'none'; // Ocultar resultados después de la selección
                    };
                    searchResultsContainer.appendChild(resultItem);
                });
            } else {
                displaySearchMessage("No se encontraron resultados para su búsqueda.", true);
            }
        }
    </script>
</body>
</html>